public class CounterRacingSimple {

	public static void main(String[] args) {
		/*
		 * 1) Почему для нового объекта приложения не создается переменная например
		 * CounterRacingSimple simple = new CounterRacingSimple() ?
		 * 
		 * Во-первых, так меньше кода, не нужно писать:
		 *  CounterRacingSimple simple = new CounterRacingSimple();
		 *  simple.doCounter();
		 *  
		 *  Во-вторых, т.к. объект у нас один, то и нет необходимости
		 *  давать ему название. Если бы у нас было несколько объектов,
		 *  то, наверное, стоило бы каждому присвоить имя.
		 *  
		 */
		new CounterRacingSimple().doCounter();
	}

	private int count = 0;

	private synchronized void increment() {
		count++;
	}

	private void doCounter() {
		/*
		 * 2) Объясните строку кода что ниже этого маркера - как из Интерфейса Runnable
		 * мы получаем объект трида?
		 * 
		 * Для создания объекта класса Thread мы передаем в его конструктор что-то, что
		 * реализует интерфейс Runnable. Для того, чтобы укоротить код мы передаем в конструктор
		 * Thread объект безымянного внутреннего класса, реализующего интерфейс Runnable 
		 */
		Thread t1 = new Thread(new Runnable() {

			@Override
			public void run() {
				/* 3) При запуске run() сколько раз повторится цикл for() ?
				 * 
				 * В теории цикл повторится 999_999 раз, но т.к. у нас два
				 * параллельных потока, то неизвестно на каком числе цикл
				 * завершит свою работу
				 */
				for (int i = 0; i < 1_000_000; i++) {
					increment();
				}
				System.out.println("t1: " + count);

			}
		});

		Thread t2 = new Thread(new Runnable() {

			@Override
			public void run() {
				for (int i = 0; i < 1_000_000; i++) {
					increment();
				}
				System.out.println("t2: " + count);

			}
		});
		/*
		 * 4) Почему если мы например запускаем 3 раза под ряд приложение println() из
		 * одного трида выводит непонятное (рэндомное число) а второй всегда ровно
		 * 2000000?
		 * 
		 * При запуске программы потоки t1 и t2 могут менять свои роли (главный/побочный)
		 * Т.е. при каждом запуске программы неизвестно чей метод run из двух потоков
		 * начнет работу первым, а т.к. поток, с которого начинается выполнение программы,
		 *  называется главным, можно сделать вывод, что первый поток, который завершит свою 
		 *  работу, будет главный поток
		 *  
		 *  Также, возможно, можно просто ответить на этот вопрос - это происходит из-за
		 *  асинхронного выполнения кода. У нас параллельных потока, которые работают независимо
		 *  друг от друга и мы не можем сказать чей метод потоков завершит работу раньше или позже
		 * 
		 */
		t1.start();
		t2.start();
		
		/* 5) Почему при выводе триды меняются порядком ) ?
		 * Опять же это происходит из-за асинхронного выполнения кода
		 * Более точно ответить не могу - не знаю. Даже join() не помогает
		 * с этим. Заметил, что последний выведенный в консоль поток всегда
		 * показывает 2_000_000, независимо какой это поток: t1 или t2
		 * 
		 */
	}

}